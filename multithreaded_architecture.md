# 多线程事件处理架构设计

## 架构概述

本设计实现了一个高性能的多线程事件处理架构，用于处理从内核获取的事件，进行事件丰富，然后执行规则匹配。

## 线程模型

### 1. 事件获取线程 (Event Fetcher Threads)
- **数量**: CPU核心数
- **职责**: 
  - 调用 `linx_engine_next()` 获取原始事件
  - 调用 `linx_event_rich()` 进行事件丰富
  - 将丰富后的事件推送到事件队列

### 2. 规则匹配线程 (Rule Matcher Threads)
- **数量**: CPU核心数 × 2
- **职责**:
  - 从事件队列中获取丰富后的事件
  - 调用 `linx_rule_set_match_rule()` 进行规则匹配
  - 触发告警处理

### 3. 主监控线程 (Main Monitor Thread)
- **数量**: 1个
- **职责**:
  - 监控系统运行状态
  - 输出性能统计信息
  - 处理系统信号

## 数据流程

```
[内核事件] 
    ↓
[linx_engine_next()] ← 事件获取线程 (CPU核数个)
    ↓
[linx_event_rich()]
    ↓
[事件队列] 
    ↓
[linx_rule_set_match_rule()] ← 规则匹配线程 (CPU核数×2个)
    ↓
[告警处理]
```

## 队列设计

### 1. 原始事件队列 (Raw Event Queue)
- **容量**: 1000个事件
- **用途**: 存储从内核获取的原始事件
- **当前状态**: 保留接口，暂未使用

### 2. 丰富事件队列 (Enriched Event Queue)
- **容量**: 2000个事件
- **用途**: 存储经过丰富处理的事件
- **特性**: 
  - 线程安全的环形缓冲区
  - 支持阻塞式生产者-消费者模式
  - 自动处理队列满和空的情况

## 同步机制

### 1. 队列同步
- **互斥锁**: 保护队列数据结构
- **条件变量**: 
  - `not_empty`: 通知消费者队列非空
  - `not_full`: 通知生产者队列非满

### 2. 统计信息同步
- **互斥锁**: 保护统计计数器
- **原子操作**: 确保统计数据的准确性

## 性能特性

### 1. 并行处理能力
- **事件获取**: 多线程并行从内核获取事件
- **规则匹配**: 更多线程并行处理规则匹配
- **负载均衡**: 自动分配工作负载

### 2. 缓冲机制
- **队列缓冲**: 平滑处理突发事件
- **背压处理**: 当队列满时自动阻塞生产者

### 3. 资源管理
- **自动扩展**: 根据CPU核心数自动调整线程数
- **优雅关闭**: 支持安全的线程终止
- **资源清理**: 自动清理所有分配的资源

## 配置选项

```c
typedef struct {
    int event_fetcher_threads;    /* 事件获取线程数 (默认: CPU核数) */
    int rule_matcher_threads;     /* 规则匹配线程数 (默认: CPU核数×2) */
    int event_queue_size;         /* 事件队列大小 (默认: 1000) */
    int enriched_queue_size;      /* 丰富事件队列大小 (默认: 2000) */
} linx_event_processor_config_t;
```

## 监控和统计

### 1. 实时统计
- **总事件数**: 从内核获取的事件总数
- **已处理事件数**: 成功丰富的事件数
- **匹配事件数**: 触发规则的事件数

### 2. 性能指标
- **处理率**: 事件处理成功率
- **匹配率**: 规则匹配成功率
- **吞吐量**: 每秒处理的事件数

### 3. 监控输出
- **每5秒**: 输出增量统计
- **每分钟**: 输出详细性能报告

## 使用方法

### 1. 初始化
```c
linx_event_processor_config_t config = {0};
linx_event_processor_init(&config);  /* 使用默认配置 */
```

### 2. 启动
```c
linx_event_processor_start();
```

### 3. 监控
```c
uint64_t total, processed, matched;
linx_event_processor_get_stats(&total, &processed, &matched);
```

### 4. 停止和清理
```c
linx_event_processor_stop();
linx_event_processor_cleanup();
```

## 优势

1. **高并发**: 充分利用多核CPU资源
2. **高吞吐**: 流水线式处理提高整体性能
3. **低延迟**: 减少单线程处理的瓶颈
4. **可扩展**: 支持动态调整线程数量
5. **稳定性**: 完善的错误处理和资源管理
6. **可监控**: 丰富的统计信息和性能指标

## 注意事项

1. **内存使用**: 多线程和队列会增加内存消耗
2. **CPU使用**: 在高负载时会占用更多CPU资源
3. **线程安全**: 确保所有共享数据的线程安全访问
4. **资源清理**: 程序退出时需要正确清理所有资源

这个架构设计为您的falco系统提供了高性能的多线程事件处理能力，能够有效处理大量的内核事件并进行实时规则匹配。